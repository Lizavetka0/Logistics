# -*- coding: utf-8 -*-
"""Кейс 4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xKoT81seYhs-3L6frrS6DS9DOfiGr9qB
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.metrics import mean_absolute_error, r2_score
import joblib
import plotly.express as px
import plotly.graph_objects as go
from scipy.optimize import minimize
import matplotlib.pyplot as plt

data = pd.read_csv('logistics_dataset.csv')

df = data.sample(frac=0.035, random_state=42)
df

df.info()

duplicates = df.duplicated().sum()
duplicates

df.isnull().sum()

df_clean = df.drop_duplicates()
df_clean

neg_distance_km = df_clean[df_clean['distance_km'] < 0]
print("Количество строк, где расстояние маршрута между пунктами отправления и назначения в километрах меньше 0: ", len(neg_distance_km))

neg_cargo_weight_tons = df_clean[df_clean['cargo_weight_tons'] < 0]
print("Количество строк, где масса перевезённого груза в тоннах меньше 0: ", len(neg_cargo_weight_tons))

neg_ton_km = df_clean[df_clean['ton_km'] < 0]
print("Количество строк, где грузооборот меньше 0: ", len(neg_ton_km))

neg_emission_factor_g_tkm = df_clean[df_clean['emission_factor_g_tkm'] < 0]
print("Количество строк, где удельные выбросы CO₂ по виду транспорта меньше 0: ", len(neg_emission_factor_g_tkm))

neg_co2_emissions_kg = df_clean[df_clean['co2_emissions_kg'] < 0]
print("Количество строк, где общие выбросы углекислого газа по маршруту меньше 0: ", len(neg_co2_emissions_kg))

neg_co2_per_liter = df_clean[df_clean['co2_per_liter'] < 0]
print("Количество строк, где масса CO₂, выделяемая при сгорании одного литра топлива меньше 0: ", len(neg_co2_per_liter))

neg_fuel_consumption_liters = df_clean[df_clean['fuel_consumption_liters'] < 0]
print("Количество строк, где оценочный объём потреблённого топлива на всём маршруте меньше 0: ", len(neg_fuel_consumption_liters))

neg_co2_per_km = df_clean[df_clean['co2_per_km'] < 0]
print("Количество строк, где интенсивность выбросов CO₂ на каждый километр маршрута меньше 0: ", len(neg_co2_per_km))

neg_co2_per_ton_km = df_clean[df_clean['co2_per_ton_km'] < 0]
print("Количество строк, где интенсивность выбросов CO₂ на одну тонну на километр меньше 0: ", len(neg_co2_per_ton_km))

neg_fuel_efficiency_l_per_100km = df_clean[df_clean['fuel_efficiency_l_per_100km'] < 0]
print("Количество строк, где Средний расход топлива на 100 км маршрута  меньше 0: ", len(neg_fuel_efficiency_l_per_100km))

print(f"Всего маршрутов: {len(df_clean)}")
print(f"Период данных: {df_clean['year'].min()}-{df_clean['year'].max()}")
print("\nТипы транспорта и их распределение:")
print(df_clean['transport_type'].value_counts())

# Анализ текущих выбросов CO2
current_co2 = df_clean['co2_emissions_kg'].sum()
print(f"Текущий углеродный след: {current_co2:.2f} кг CO2 в год")

# Анализ по типам транспорта
co2_by_transport = df_clean.groupby('transport_type')['co2_emissions_kg'].sum().sort_values(ascending=False)
print("\nВыбросы CO2 по типам транспорта:")
print(co2_by_transport)

total_stats = {
    'total_co2_tonnes': df_clean['co2_emissions_kg'].sum() / 1000,
    'total_distance': df_clean['distance_km'].sum(),
    'total_cargo': df_clean['cargo_weight_tons'].sum(),
    'avg_emission_per_tonkm': df_clean['emission_factor_g_tkm'].mean()
}
total_stats

transport_stats = df_clean.groupby('transport_type').agg({
    'co2_emissions_kg': ['sum', 'mean'],
    'distance_km': 'mean',
    'cargo_weight_tons': 'mean',
    'emission_factor_g_tkm': 'mean',
    'fuel_efficiency_l_per_100km': 'mean'
}).sort_values(('co2_emissions_kg', 'sum'), ascending=False)

transport_stats['co2_share'] = transport_stats[('co2_emissions_kg', 'sum')] / df_clean['co2_emissions_kg'].sum() * 100

transport_stats

# Визуализация текущего состояния
fig = px.bar(co2_by_transport.reset_index(),
             x='transport_type', y='co2_emissions_kg',
             title='Текущие выбросы CO2 по типам транспорта')
fig.show()

plt.figure(figsize=(18, 12))

# График распределения выбросов
plt.subplot(2, 2, 1)
sns.histplot(df_clean['co2_emissions_kg'], bins=50, kde=True)
plt.title('Распределение выбросов CO₂ по маршрутам')
plt.xlabel('кг CO₂')

plt.tight_layout()
plt.show()

plt.figure(figsize=(18, 12))

# График зависимости выбросов от расстояния
plt.subplot(2, 2, 4)
sns.scatterplot(data=df_clean, x='distance_km', y='co2_emissions_kg',
               hue='transport_type', size='cargo_weight_tons', alpha=0.6)
plt.title('Зависимость выбросов от расстояния')
plt.xlabel('Расстояние (км)')
plt.ylabel('Выбросы CO₂ (кг)')

plt.tight_layout()
plt.show()

df_clean['load_factor'] = df_clean['cargo_weight_tons'] / df_clean.groupby('transport_type')['cargo_weight_tons'].transform('max')
df_clean['distance_category'] = pd.cut(df_clean['distance_km'],
                                 bins=[0, 200, 500, 1000, np.inf],
                                 labels=['short', 'medium', 'long', 'extra_long'])

# Разделение данных
X = df_clean[['transport_type', 'distance_km', 'cargo_weight_tons', 'load_factor', 'distance_category']]
y = df_clean['co2_emissions_kg']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Создание пайплайна
numeric_features = ['distance_km', 'cargo_weight_tons', 'load_factor']
categorical_features = ['transport_type', 'distance_category']

preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numeric_features),
        ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_features)
    ])

pipeline = Pipeline([
    ('preprocessor', preprocessor),
    ('regressor', RandomForestRegressor(random_state=42))
])

param_grid = {
    'regressor__n_estimators': [100, 200],
    'regressor__max_depth': [None, 10, 20],
    'regressor__min_samples_split': [2, 5]
}

grid_search = GridSearchCV(pipeline, param_grid, cv=5, scoring='neg_mean_absolute_error', n_jobs=-1)
grid_search.fit(X_train, y_train)

# Оценка модели
model = grid_search.best_estimator_
y_pred = model.predict(X_test)

print(f"MAE: {mean_absolute_error(y_test, y_pred):.2f} кг")
print(f"R2 Score: {r2_score(y_test, y_pred):.2f}")

joblib.dump(model, 'co2_emission_model.pkl')

# Оптимизационная модель

class LogisticsOptimizer:
    def __init__(self, model_path, transport_options):
        self.model = joblib.load(model_path)
        self.transport_options = transport_options
        self.transport_types = transport_options['transport_type'].unique()

    def predict_co2(self, transport_type, distance, weight):
        """Предсказание выбросов CO2 для конкретного маршрута"""
        max_weight = self.transport_options[self.transport_options['transport_type'] == transport_type]['cargo_weight_tons'].max()
        load_factor = weight / max_weight

        # Определяем категорию расстояния
        if distance <= 200:
            dist_cat = 'short'##
        elif distance <= 500:
            dist_cat = 'medium'
        elif distance <= 1000:
            dist_cat = 'long'
        else:
            dist_cat = 'extra_long'

        input_data = pd.DataFrame([{
            'transport_type': transport_type,
            'distance_km': distance,
            'cargo_weight_tons': weight,
            'load_factor': load_factor,
            'distance_category': dist_cat
        }])

        return self.model.predict(input_data)[0]

    def optimize(self, total_cargo, origin, destination, distance):
        """Оптимизация распределения груза"""
        # Доступные типы транспорта
        available_transports = self.transport_options['transport_type'].unique()
        n_transports = len(available_transports)

        # Целевая функция
        def objective(x):
            weights = x * total_cargo
            total_co2 = 0
            for i, transport in enumerate(available_transports):
                if weights[i] > 0:
                    total_co2 += self.predict_co2(transport, distance, weights[i])
            return total_co2

        # Ограничения
        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})  # Сумма долей = 1

        # Границы
        bounds = [(0, 1) for _ in range(n_transports)]

        # Начальное предположение (равномерное распределение)
        x0 = np.ones(n_transports) / n_transports

        # Оптимизация
        result = minimize(objective, x0, method='SLSQP',
                         bounds=bounds, constraints=constraints)

        # Обработка результатов
        if result.success:
            optimal_weights = result.x * total_cargo
            solution = pd.DataFrame({
                'transport_type': available_transports,
                'weight': optimal_weights,
                'co2': [self.predict_co2(t, distance, w)
                        for t, w in zip(available_transports, optimal_weights)]
            })
            solution = solution[solution['weight'] > 0.1]  # Фильтрация незначительных
            return solution.sort_values('co2')
        else:
            print("Оптимизация не удалась:", result.message)
            return None

# Пример использования оптимизатора
optimizer = LogisticsOptimizer('co2_emission_model.pkl', df_clean)
solution = optimizer.optimize(total_cargo=2.643378,
                            origin='Dayton OH',
                            destination='Rest of OH',
                            distance=0.213486	)
print("\nОптимальное распределение груза:")
print(solution)

# Интерактивная визуализация

def plot_optimization(current_df, optimized_df):
    """Сравнение текущей и оптимизированной сети"""
    fig = go.Figure()

    # Текущие маршруты
    fig.add_trace(go.Scattergeo(
        lon = current_df['origin_lon'].tolist() + current_df['destination_lon'].tolist(),
        lat = current_df['origin_lat'].tolist() + current_df['destination_lat'].tolist(),
        mode = 'markers',
        marker = dict(size=10, color='red'),
        name = 'Текущие маршруты'
    ))

    # Оптимизированные маршруты
    fig.add_trace(go.Scattergeo(
        lon = optimized_df['origin_lon'].tolist() + optimized_df['destination_lon'].tolist(),
        lat = optimized_df['origin_lat'].tolist() + optimized_df['destination_lat'].tolist(),
        mode = 'markers',
        marker = dict(size=10, color='green'),
        name = 'Оптимизированные маршруты'
    ))

    # Линии маршрутов
    for _, row in current_df.iterrows():
        fig.add_trace(go.Scattergeo(
            lon = [row['origin_lon'], row['destination_lon']],
            lat = [row['origin_lat'], row['destination_lat']],
            mode = 'lines',
            line = dict(width=1, color='red'),
            showlegend=False
        ))

    for _, row in optimized_df.iterrows():
        fig.add_trace(go.Scattergeo(
            lon = [row['origin_lon'], row['destination_lon']],
            lat = [row['origin_lat'], row['destination_lat']],
            mode = 'lines',
            line = dict(width=1, color='green', dash='dot'),
            showlegend=False
        ))

    fig.update_geos(projection_type="natural earth")
    fig.update_layout(title='Сравнение текущей и оптимизированной логистической сети')
    fig.show()

current_routes = df_clean.head(3).copy()
current_routes['origin_lat'] = [39.76, 42.9634, 27.9517]
current_routes['origin_lon'] = [-84.19, -85.6681, -82.4588]
current_routes['destination_lat'] = [41.38, 40.7143, 35.7595]
current_routes['destination_lon'] = [-82.22, -74.0060, -79.0193]

optimized_routes = current_routes.copy()
optimized_routes['transport_type'] = ['train', 'ship', 'train']

plot_optimization(current_routes, optimized_routes)